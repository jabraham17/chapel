// generated by Fast Light User Interface Designer (fluid) version 1.0305

#include "chpldbg_fl.h"
static std::string data_pass_delimiter; 
#define MSG_SIZE 512
static CommandLog *commLog = (CommandLog *)0; 
static Fl_Group *commIn = (Fl_Group*)0; 
static LocaleTab** localeTabs; 
static Fl_Text_Buffer **tabBuffs; 
static Fl_Text_Buffer **locale_buffers; 

Fl_Double_Window *MainWindow=(Fl_Double_Window *)0;

static void cb_MainWindow(Fl_Double_Window*, void*) {
  MainWindow->hide();
}

Fl_Tabs *tabs=(Fl_Tabs *)0;

Fl_Text_Display *disp=(Fl_Text_Display *)0;

Fl_Menu_Bar *menu=(Fl_Menu_Bar *)0;

int start_fltk_gui(int numTabs, int r_fd, int w_fd) {
  localeTabs = (LocaleTab**) malloc(sizeof(LocaleTab*) * numTabs);
  Fl_Text_Buffer *logBuf = new Fl_Text_Buffer();
  vector<string> *logVect = new vector<string>(0);
  tabBuffs = (Fl_Text_Buffer **) malloc(numTabs * sizeof(Fl_Text_Buffer *));
  int i;
  for(i = 0; i < numTabs; i++){
    tabBuffs[i] = new Fl_Text_Buffer();
  }
  locale_buffers = &tabBuffs[1];
  
  pthread_t threads[2]; // stores read and write thread ID's 
  		        // threads[0] = reader thread
  		        // thread [1] = writer t
  /* Create reader thread */
  if(pthread_create(&threads[0], NULL, &fltk_reader_thread, (void *) &r_fd)){
    tabBuffs[0]->append("error creating fltk_writer_thread");
  }
  { MainWindow = new Fl_Double_Window(1255, 750, "chpldbg");
    MainWindow->color((Fl_Color)21);
    MainWindow->selection_color(FL_LIGHT1);
    MainWindow->callback((Fl_Callback*)cb_MainWindow);
    { tabs = new Fl_Tabs(65, 55, 1125, 556, "Tabs");
      tabs->box(FL_DOWN_BOX);
      {make_tabs(numTabs, tabBuffs);}
      tabs->callback(tabs_cb);
      tabs->end();
      Fl_Group::current()->resizable(tabs);
    } // Fl_Tabs* tabs
    { Fl_Group* o = new Fl_Group(65, 630, 1125, 75);
      o->box(FL_DOWN_BOX);
      { disp = new Fl_Text_Display(80, 640, 1095, 55);
        disp->selection_color((Fl_Color)86);
        Fl_Group::current()->resizable(disp);
        disp->buffer(logBuf);
        commLog = new CommandLog(logVect, disp, logBuf);
      } // Fl_Text_Display* disp
      o->end();
    } // Fl_Group* o
    { menu = new Fl_Menu_Bar(0, 0, 1220, 20);
      menu->window()->hotspot(menu);
    } // Fl_Menu_Bar* menu
    {commIn = new CommInput(65,710,1125,35,commLog,w_fd); commIn->deactivate();}
    MainWindow->size_range(1220, 775);
    MainWindow->end();
  } // Fl_Double_Window* MainWindow
  Fl::lock();
  MainWindow->show();
  commIn->activate();
  Fl::focus(commIn);
  
  // indicate to backend the GUI is ready
  write(w_fd, "ready\n", 7);
  
  int result = Fl::run();
  
  return result;
}

void make_tabs(int numTabs, Fl_Text_Buffer** tabBuffs) {
  int i = 0;
  char* names[numTabs-1];
  int numAvailable = get_names(names, numTabs-1);
  if((numTabs-1) > numAvailable){
    printf("ERROR: There are only %d locales available \n", numAvailable);
    exit(0);
  }
  for(i = 0; i < numTabs; i++){
    if(i == 0){
      localeTabs[i] = new LocaleTab(65, 80, 1125, 530, tabBuffs[i], "Local");
    } else {
      localeTabs[i] = new LocaleTab(65, 80, 1125, 530, tabBuffs[i], names[i-1]);
      localeTabs[i]->labelcolor(FL_RED);
    }
    localeTabs[i]->color((Fl_Color)48);
    localeTabs[i]->end();
  }
}

void tabs_cb(Fl_Widget* w, void*) {
  Fl_Tabs *t = (Fl_Tabs*) w;
  t->selection_color( (t->value())->color() );
}

int get_names(char** names, int size) {
  int numAvailable = 0;
  char *localeNames = strdup(getenv("GASNET_SSH_SERVERS"));
  int len = strlen(localeNames);
  int i = 0, j = 0;
  numAvailable++;
  names[0] = &localeNames[0];
  for(i = 0; i < len; i++){
    if(localeNames[i] == ' ' && j < size){
      localeNames[i] = '\0';
      names[++j] = &localeNames[++i];
      numAvailable++;
    }
  }
  if(numAvailable == 1){
    printf("Error: no servers available\n");
  }
  return numAvailable;
}

void * fltk_reader_thread(void *arg) {
  int r_fd = *(int *) arg;
  int bytes_read;
  int ix;
  char msg_buf[MSG_SIZE];
  std::string s;
  std::string locales_str;
  std::string msg;
  
  read(r_fd, msg_buf, MSG_SIZE);
  data_pass_delimiter = std::string(msg_buf);
  
  while(true){
    memset(msg_buf, 0, MSG_SIZE);
    if((bytes_read = read(r_fd, msg_buf, MSG_SIZE)) < 0){
    	tabBuffs[0]->append("error with fltk_read_thread\n");
    }
    msg_buf[bytes_read] = '\n';
    msg_buf[bytes_read+1] = '\0';
    
    s = std::string(msg_buf);
  
    size_t size = s.find(data_pass_delimiter);
    if(size != string::npos){
      // message sent to specific locale tab
      msg = s.substr(size+data_pass_delimiter.length(), string::npos);  
      locales_str = s.substr(0, s.find(data_pass_delimiter));
      ix = atoi(locales_str.c_str()) + 1;
    } else {
      // message sent to main tab
      msg = s.substr(0, string::npos);
      ix = 0;  
    }
  
    /* write to the appropriate tabs */
    Fl::lock();
    tabBuffs[ix]->append(msg.c_str());
    Fl::unlock();
    Fl::awake();
  }
}
